---
title: Movebank Results
output: 
  github_document:
    df_print: kable
author: Alec Robitaille
date: "`r Sys.Date()`"
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

knitr::opts_chunk$set(echo = TRUE,
											eval = TRUE,
											out.width = '100%',
											fig.width = 11)
```




```{r pkgs}
# Packages ----------------------------------------------------------------
library(data.table)
library(taxize)
library(ggplot2)
library(patchwork)
```

```{r data}
# Data --------------------------------------------------------------------
details <- fread('data-sources/details.csv')
taxes <- fread('data-sources/taxes.csv')
DT <- fread('data-sources/taxed-details.csv')
```


`taxon_ids` column

```{r checkids}
details[, .N, .(is.na(taxon_ids), taxon_ids == '')]
```


Out of `r details[taxon_ids == '', .N]` rows with seemingly valid `taxon_ids`, there are up to 17 species listed in any row. Eg. 


```{r eglong}
details[id == 422952928]$taxon_ids
```

Grabbing the family and class, then combining the taxonomies with the study details dataset, we have `r DT[, .N]` species by study rows. 

```{r}
# First, recode missing class and family
DT[class == "" | is.na(class), class := "*Unknown*"]
DT[family == "" | is.na(family), family := "*Unknown*"]
```

Careful double counting, because the `DT` dataset now has duplicated study rows for each parsed taxon.

```{r unique}
# Grab the unique rows based on study id
countDT <- unique(DT, by = 'id')


# Count by class
countDT[, .N, class][order(class)]
```



```{r class}
ggplot(countDT) + 
	geom_bar(aes(class, fill = i_have_download_access)) +
	guides(fill = FALSE) +
	# scale_y_log10() +
	labs(x = 'Class', y = 'Number of studies')
```


# *Mammalia*

Just exploring mammals, the following figures show download access TRUE in blue, 
and FALSE in red. Note: the plots are separated into chunks based on an even 
number of observations in each chunk. 


```{r base}
# Set up the base plot
g <- ggplot() + 
	geom_col(aes(factor(family, sort(unique(family), TRUE)), y,
							 fill = i_have_download_access)) +
  facet_wrap(~ cut_number(y, 2), scales = 'free') +
	coord_flip() + 
	guides(fill = FALSE)
```



## Number of studies by family

```{r studies}
g %+% countDT[class == 'Mammalia', .(y = .N), .(i_have_download_access, family)] +
	labs(y = 'Number of studies', x = 'Family')
```


## Number of individuals by family
```{r numbids}
g %+% countDT[class == 'Mammalia', .(y = sum(number_of_individuals, na.rm = TRUE)),
							.(i_have_download_access, family)] +
	labs(y = 'Number of individuals', x = 'Family')
```

## Number of relocations by family
```{r numblobs}
g %+% countDT[class == 'Mammalia', .(y = sum(number_of_deployed_locations, na.rm = TRUE)),
							.(i_have_download_access, family)] +
	labs(y = 'Number of relocations', x = 'Family') +
	facet_wrap(~cut_number(y, 4), scales = 'free')
```


```{r}
countDT[, .(N = sum(number_of_deployed_locations), family = family[[1]], class = class[[1]],
						i_have_download_access = i_have_download_access[[1]]), 
				by = matched_name][order(-N, class)][, .SD[1:3], by = class]
```

Some elements of the database are strange. How do these datasets have last deployed
timestamps in the 10-25 year future?

```{r}
DT[matched_name == 'Polemaetus bellicosus'][, .(
	matched_name,
	family,
	class,
	sensor_type_ids,
	timestamp_first_deployed_location,
	timestamp_last_deployed_location,
	number_of_deployed_locations
)]
```
